<?xml version="1.0" encoding="UTF-8" ?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Analog Hors - Writing</title><description>Analog&apos;s Blog</description><link>https://analog-hors.github.io/site/</link><language>en</language><atom:link href="https://analog-hors.github.io/site/writing/feed.xml" rel="self" type="application/rss+xml"></atom:link><item><title>Writing an NES emulator: Part 1 - The 6502 CPU</title><description>After an immense amount of time of not sticking with a project, I finally decided to pick up writing an NES emulator again, a project which I dropped years ago. I&apos;m not really sure I&apos;ll pull through with it this time, but I did get the CPU implemented: The ubiquitous MOS Technology 6502.</description><link>https://analog-hors.github.io/site/pones-p1/</link><pubDate>Sun, 2 Apr 2023 00:00:00 +0000</pubDate><guid>https://analog-hors.github.io/site/pones-p1/</guid></item><item><title>Magical Bitboards and How to Find Them: Sliding move generation in chess</title><description>Efficiently generating moves for sliding pieces is a tricky problem in chess programming. The obvious strategy is to iterate in each movement direction one square at a time until an obstruction is reached. However, there is a much, much faster way: Magic Bitboards. This article explains the theory, goes through a simple implementation, and notes improvements made in real-world code.</description><link>https://analog-hors.github.io/site/magic-bitboards/</link><pubDate>Sat, 24 Sep 2022 00:00:00 +0000</pubDate><guid>https://analog-hors.github.io/site/magic-bitboards/</guid></item></channel></rss>